# -*- sh -*-

## Determine the name of the shell
shell_name="sh"
test x"$ZSH_VERSION" = x"" || shell_name="zsh"
test x"$BASH_VERSION" = x"" || shell_name="bash"

## Determine whether this is an interactive shell
is_interactive=0
[[ $- == *i* ]] && is_interactive=1

## Determine whether this is a login shell
is_login=0
case "$shell_name" in
	bash)
		shopt -q login_shell && is_login=1
		;;
	zsh)
		[[ -o login ]] && is_login=1
		;;
esac

## Detect Mac OS X
is_macosx=0
[ x"$Apple_Ubiquity_Message" = x"" ] || is_macosx=1
[ x"$TERM_PROGRAM" = x"Apple_Terminal" ] && is_macosx=1
[ x"$TERM_PROGRAM" = x"iTerm.app" ] && is_macosx=1

## Terminal escape sequences
have_colorterm=0
nps=`printf "\001"`
npe=`printf "\002"`
esc=`printf "\033"`
test "$shell_name" = "bash" && esc='\e'
ansi_reset="${esc}[0m"
ansi_bold="${esc}[1m"
ansi_black="${esc}[0m${esc}[30m"
ansi_red="${esc}[0m${esc}[31m"
ansi_green="${esc}[0m${esc}[32m"
ansi_yellow="${esc}[0m${esc}[33m"
ansi_blue="${esc}[0m${esc}[34m"
ansi_magenta="${esc}[0m${esc}[35m"
ansi_cyan="${esc}[0m${esc}[36m"
ansi_normal="${ansi_reset}"
ansi_bnormal="${ansi_reset}${ansi_bold}"

case "$TERM" in
	sun-color|linux)
		ansi_white="${ansi_normal}"
		ansi_bblack="${ansi_black}${ansi_bold}"
		ansi_bred="${ansi_red}${ansi_bold}"
		ansi_bgreen="${ansi_green}${ansi_bold}"
		ansi_byellow="${ansi_yellow}${ansi_bold}"
		ansi_bblue="${ansi_blue}${ansi_bold}"
		ansi_bmagenta="${ansi_magenta}${ansi_bold}"
		ansi_bcyan="${ansi_cyan}${ansi_bold}"
		ansi_bwhite="${ansi_white}${ansi_bold}"
		have_colorterm=1
		;;
	xterm|xterm-color|xterm-256color)
		ansi_white="${esc}[37m"
		ansi_bblack="${esc}[90m"
		ansi_bred="${esc}[91m"
		ansi_bgreen="${esc}[92m"
		ansi_byellow="${esc}[93m"
		ansi_bblue="${esc}[94m"
		ansi_bmagenta="${esc}[95m"
		ansi_bcyan="${esc}[96m"
		ansi_bwhite="${esc}[97m"    
		have_colorterm=1
		;;
	*)
		ansi_reset=""
		ansi_bold=""
		ansi_black=""
		ansi_red=""
		ansi_green=""
		ansi_yellow=""
		ansi_blue=""
		ansi_magenta=""
		ansi_cyan=""
		ansi_normal=""
		ansi_bnormal=""
		ansi_white=""
		ansi_bblack=""
		ansi_bred=""
		ansi_bgreen=""
		ansi_byellow=""
		ansi_bblue=""
		ansi_bmagenta=""
		ansi_bcyan=""
		ansi_bwhite=""
		;;
esac

if test $shell_name = zsh ; then
	setopt promptsubst
	nps='%{'
	npe='%}'
	prompt_user='%n'
	prompt_host='%m'
	prompt_path=' ${curdir}'
	prompt_ind='%#'
	prompt_ps2='%_>'
elif test $shell_name = bash ; then
	nps='\['
	npe='\]'
	prompt_user='\u'
	prompt_host='\h'
	prompt_path=' \W'
	prompt_ind='\$'
	prompt_ps2='>'
else
	prompt_user="$LOGNAME"
	prompt_host=`hostname | cut -f1 -d.`
	prompt_path=''
	prompt_ind='$'
	prompt_ps2='>'
fi

pbit_preamble="${nps}${ansi_reset}${ansi_bnormal}${npe}[${nps}${ansi_normal}${npe}\${df__time} "
pbit_postamble="${nps}${ansi_bnormal}${npe}]${nps}${ansi_bred}${npe}${prompt_ind} ${nps}${ansi_normal}${npe}"

if test -z "$SSH_CLIENT" && test -z"$SSH_CONNECTION" ; then
	pbit_user="${nps}${ansi_bgreen}${npe}${prompt_user}"
	SHELL_LOCATION="local"
	is_local=1
else
	pbit_user="${nps}${ansi_bcyan}${npe}${prompt_user}${nps}${ansi_green}${npe}@${nps}${ansi_bcyan}${npe}${prompt_host}"
	SHELL_LOCATION="remote"
	is_local=0
fi
export SHELL_LOCATION

pbit_vcs="${nps}${ansi_bblue}${npe}\${df__branch}${nps}${ansi_cyan}${ansi_bold}${npe}"
pbit_path="${nps}${ansi_reset}${ansi_bmagenta}${npe}${prompt_path}"

def_ps1="${pbit_preamble}${pbit_user}${pbit_vcs}${pbit_path}${pbit_postamble}"
def_ps2="${nps}${ansi_reset}${ansi_bred}${npe}${prompt_ps2}${nps}${ansi_normal}${npe} "
def_prompt_command="df__precmd"

if type -p emacs 2>&1 >/dev/null ; then
    def_visual="emacs"
elif type -p jed 2>&1 >/dev/null ; then
    def_visual="jed"
elif type -p nano 2>&1 >/dev/null ; then
    def_visual="nano"
fi

## Update shell variables used when evaluating $PS1 (including updating the
## window title and, on Mac OS X, current working directory)
df__precmd()
{
	df__vcbranch
	HOSTNAME=`hostname`
	here=`pwd`
	if test x"$here" = x"$HOME" ; then
		curdir='~'
	else
		curdir=`basename "$here"`
	fi
	if test x"$TERM" = x"xterm" || test x"$TERM" = x"xterm-color" || test x"$TERM" = x"xterm-256color" ; then
		test x"$NODENAME" = x"" && NODENAME=`echo $HOSTNAME|cut -f1 -d.`
		suf='$'
		test x"$UID" = x"0" && suf='#'
		if test x"$TERM_PROGRAM" = x"Apple_Terminal" ; then
			printf "\033]2;[%s@%s%s]%s\007" "$LOGNAME" "$NODENAME" "$df__branch" "$suf"
		else
			printf "\033]2;[%s@%s%s %s]%s\007" "$LOGNAME" "$NODENAME" "$df__branch" "$curdir" "$suf"
			printf "\033]1;%s@%s\007" "$LOGNAME" "$NODENAME"
		fi
	fi
	if test x"$TERM_PROGRAM" = x"Apple_Terminal" ; then
		local SEARCH=' '
		local REPLACE='%20'
		PWD_URL="file://$HOSTNAME${PWD//$SEARCH/$REPLACE}"
		printf "\e]7;%s\a" "$PWD_URL/"
	fi
	df__time=`date +%H%M%S`
}

precmd()
{
	df__precmd
}

## Determine what VCS branch, if any, the CWD is on
df__vcbranch()
{
	branch=`( git symbolic-ref HEAD | sed -e 's!^refs/heads/!!' ) 2>/dev/null`
	if test x"$branch" = x"" ; then
		df__branch=''
	else
		df__branch=" git:$branch"
	fi
}

## Add a location to $PATH if it exists
df__addpath()
{
	if test -d "$1" ; then
	case "$PATH" in
		"*:$1:*|*:$1|$1:*")
			return
			;;
		*)
			PATH="$1:$PATH"
			;;
		esac
	fi
}

df__addpath /usr/local/bin
df__addpath /usr/local/git/bin
df__addpath /usr/local/mysql/bin
df__addpath /opt/local/bin
df__addpath /opt/xapian/bin
df__addpath /opt/txsuite/bin
df__addpath /opt/csw/bin
df__addpath /usr/gnu/bin
df__addpath /opt/ports/bin
df__addpath /Local/Library/PostgreSQL/Current/bin
df__addpath /Library/PostgreSQL/Current/bin
df__addpath "$HOME/Tools"
export PATH

## If 'ls' is GNU ls, then enable colourisation via 'ls --color=auto'
## Otherwise, the alias (if any) is OS-dependent
is_gnu_ls=0
if ls --version 2>/dev/null >/dev/null ; then
	is_gnu_ls=1
fi
if test -x "$HOME/.dircolors" ; then
	eval `"$HOME/.dircolors"`
elif test $is_gnu_ls -eq 1 ; then
	eval `dircolors -b`
fi
if test $is_gnu_ls -eq 1 ; then
	alias ls='ls --color=auto'
fi

CLICOLOR=1
export CLICOLOR
export LSCOLORS
export LS_COLORS

## On Mac OS X interactive shells:
# if Kaleidoscope is installed, use it for 'git diff' and 'svn diff'
# if TextMate's command-line integration is available, use it as $VISUAL
if test $is_macosx -eq 1 && test $is_interactive -eq 1 ; then
	for d in /usr/local/bin /opt/local/bin "$HOME/bin" "$HOME/Tools" /Volumes/iDisk/Tools ; do
		if test -x "$d/kaleidoscope-git" ; then
		   GIT_EXTERNAL_DIFF="$d/kaleidoscope-git"
		   export GIT_EXTERNAL_DIFF
		fi
		if test -x "$d/ksdiff" ; then
			SVN_EXTERNAL_DIFF="$d/ksdiff"
			export SVN_EXTERNAL_DIFF
		fi
		if test -x "$d/mate" ; then
			def_visual="$d/mate -w"
			export VISUAL
		fi
	done
fi

## Set CVS_RSH
CVS_RSH=ssh
export CVS_SSH

## In a new login shell, print a banner
if [ $is_interactive -eq 1 ] && [ $is_login -eq 1 ] ; then
	col="${ansi_byellow}"
	[ $is_local -eq 1 ] && col="${ansi_bmagenta}"
	printf "${ansi_reset}${col}"
	printf -- "-%.0s" {1..78}
	printf "${ansi_reset}\n"
	printf "${col}%s@%s - %s (%s)${ansi_reset}\n" "`whoami`" ""`hostname`"" "`uname -sr`" "`uname -m`"
	uptime=$(echo `uptime`)
	printf "${ansi_reset} %s\n" "$uptime"
	date=`date +"%A %e %B %Y %H:%M:%S %z (%Z)"`
	printf "${ansi_bwhite} %s\n" "$date"
	printf "${ansi_reset}${col}"
	printf -- "-%.0s" {1..78}
	printf "${ansi_reset}\n"
fi

